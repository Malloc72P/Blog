## 블로그를 구현하면서 겪었던 시행착오들

![블로그는 쉽기만 할 줄 알았는데...](../../../../../../../../images/cafe-1.jpg)

블로그를 직접 구현하면서 겪었던 시행착오를 여러분과 공유하려고 합니다.  
처음엔 단순한 블로그이니, 무난하게 구현하고 배포해야지~ 라고 생각했습니다.  
다만, 그렇게 간단하지는 않더라구요. 🥹

기억에 남는 황당한(?) 이슈를 간단하게 요약하면 아래와 같습니다.

- 날짜로 인한 Hydration 에러가 발생하는 이슈
- z-index값이 낮은 엘리먼트가 높은 엘리먼트 위에 배치되는 이슈

## 날짜로 인한 Hydration 에러가 발생하는 이슈

React의 Hydration 에러는 SSR을 통해 받은 초기 HTML과 브라우저에서 Hydration을 위해 렌더링한 HTML 내용이 다른 경우 발생합니다.  
제 경우엔 Vercel에 배포한 경우만 Hydration 에러가 발생하는 상황이었습니다.  
정리하면...

- 로컬 dev 모드에서는 에러 발생 안함.
- 로컬 production 모드에서도 발생 안함.
- Vercel에 배포한 경우엔 Hydration 에러 발생.

와... 정말 황당했습니다. 대체 뭐가 문제이길래 배포한 버전에서만 에러가 발생하는걸까요?  
처음엔 너무 막막했습니다. 로컬에서 상황재현이 안되니, 에러 로그만 보고 해결해야 하는 상황이었습니다.

문제는 에러 로그도 아래와 같이 출력되는 상황이라, 왜 발생하는지 알기 어려웠습니다.

```
Uncaught Error: Minified React error #418;
    visit https://react.dev/errors/418?
    args[]=for the full message or use the non-minified dev environment for full errors and additional helpful warnings.
    ...
```

![아...](../../../../../../../../images/frustrated2.jpg)

## React Error #418

https://react.dev/errors/418

리액트는 전송되는 바이트 크기를 줄이기 위해, 전체 오류 메세지를 전송하지 않습니다.  
그래서 위와 같은 에러 메세지가 출력된 상황입니다.

418 에러의 원래 내용은 아래와 같습니다.

```
Hydration failed because the server rendered HTML didn't match the client.
As a result this tree will be regenerated on the client.
This can happen if a SSR-ed Client Component used:
...
```

즉, Hydration mismatch 에러가 발생한 상황인 것이죠.
문제는, 왜 Hydration mismatch가 발생했을까요?

## Hydration mismatch 에러의 원인을 찾는 과정

![대체 어디서 Hydration mismatch가 발생하는거야!!!](../../../../../../../../images/finding.jpg)

Hydration mismatch 에러는 SSR로 받은 HTML과 클라이언트에서 렌더링한 HTML이 달라서 하이드레이션에 실패하는 에러입니다.  
주로 아래와 같은 경우에 발생합니다.

1. window객체와 같이 브라우저 전용 API를 통해 분기(if...else)하는 경우
2. Date.now()와 같이 현재 시간을 사용하여 mismatch가 발생하는 경우
3. 서버와 유저 로케일이 달라서 Date Formatting이 다르게 적용된 경우

그 외에도 더 있지만, 제 경우는 3번 때문에 발생한 문제였습니다.

## Vercel 빌드 서버가 미국이라 발생한 문제

결론부터 말씀드리면, DayJs를 잘못 사용했기 때문에 발생한 문제입니다.  
문제의 코드는 다음과 같습니다

```tsx
<div className="text-gray-400 text-xs sm:text-[16px] mt-1 sm:mt-2">
  {DateUtil.Dayjs(post.date).format('YYYY/MM/DD a hh:mm')}
</div>
```

Frontmatter의 시간 정보는 아래와 같이 한국 기준 시간으로 작성합니다.

```ts
export const metadata = {
  // ...생략
  date: '2025-03-05 22:42', // 한국 기준 시간
};
```

Dayjs는 현재 실행 환경의 Locale Time을 그대로 사용합니다.  
서버는 미국, 브라우저는 한국 타임존을 사용하게 됩니다.  
그러므로 서버와 브라우저에서 실행된 `DateUtil.Dayjs(post.date)`의 결과는 달라집니다.  
이로 인해 서버와 클라이언트가 같은 값을 렌더링하지 못해 Hydration mismatch 오류가 발생한 것 입니다.

이 문제를 해결하기 위해 format이라는 유틸 함수를 만들었습니다.  
실행 환경의 타임존과 관계 없이, 항상 한국 타임존이 지정되도록 하였습니다.

```ts
const format = (date: string | Date | dayjs.Dayjs, formatType: IDateFormat) => {
  // 매개변수 date를 Dayjs 객체로 재생성.
  // DayJs객체를 생성할 때 서울 타임존을 사용해서 객체를 생성한다.
  let dayjsObj: dayjs.Dayjs = dayjs.isDayjs(date)
    ? date
    : CustomDayJS.tz(date, DateUtil.tzString.seoul);

  // 포맷 문자열을 DateFormat객체에서 꺼내고 적용한다.
  const format = DateFormat[formatType];
  const result = dayjsObj.format(format);

  return result;
};
```

이렇게 하여 실행 환경의 타임존과 무관하게 항상 같은 타임존이 적용되어,
서버와 클라이언트의 랜더링 결과가 달라지는 Hydration mismatch 문제를 해결할 수 있었습니다.
원인을 찾는 것 부터 까다로워서 해결하느라 꽤 애먹었던 이슈였습니다 ㅎㅎ. 🥹

export const metadata = {
  title: 'Nextjs로 블로그 만들기 시리즈 Part 3. 블로그를 구현하면서 겪었던 시행착오 1',
  description:
    '개인 블로그를 직접 구현하기 위해 어떤 프레임워크와 호스팅 업체를 고를지 고민한 내용을 다룬 글 입니다.',
  series: 'blog-making-series',
  tags: ['Next.js', 'Vercel', 'Hydration', 'React error #418', 'DayJs'],
  date: '2025-03-07 19:53',
};
