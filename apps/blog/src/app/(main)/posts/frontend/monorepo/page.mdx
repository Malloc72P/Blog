import { Constants } from '@libs/constants';

export const metadata = {
  title: 'Monorepo로 관리하는 프론트엔드 프로젝트 구조 설계',
  description:
    '프론트엔드 프로젝트에서 Monorepo를 활용하여 코드베이스를 효율적으로 관리하는 방법에 대해 다루는 포스트입니다.',
  openGraph: {
    title: 'Monorepo로 관리하는 프론트엔드 프로젝트 구조 설계',
    description:
      '프론트엔드 프로젝트에서 Monorepo를 활용하여 코드베이스를 효율적으로 관리하는 방법에 대해 다루는 포스트입니다.',
    type: 'article',
    url: '/posts/frontend/monorepo',
    ...Constants.openGraph,
  },
  series: 'frontend',
  tags: ['Monorepo', 'turbo'],
  date: '2026-01-12 08:11',
};

## Monorepo란?

Monorepo는 여러 개의 프로젝트를 하나의 저장소(Repository)에서 관리하는 방식을 의미합니다.
이 접근 방식은 코드베이스의 일관성을 유지하고, 코드 재사용성을 높이며, 종속성 관리를 용이하게 하는 데 도움이 됩니다.

### Monorepo의 특징

- 일관된 코드베이스: 모든 프로젝트가 동일한 저장소에 있기 때문에 코드 스타일과 규칙을 일관되게 적용할 수 있습니다.
- 코드 재사용성: 공통 모듈이나 라이브러리를 쉽게 공유하고 재사용할 수 있습니다.
- 종속성 관리: 프로젝트 간의 종속성을 쉽게 관리할 수 있습니다.
- 통합된 빌드 및 배포: 전체 프로젝트를 한 번에 빌드하고 배포할 수 있어 효율적입니다.

### 만약 Monorepo를 사용하지 않는다면?

저장소 하나에 프로젝트가 하나씩 존재하는 방식은 폴리레포(Polyrepo)라고 불립니다.
단순한 프로젝트에서는 폴리레포가 관리가 더 쉬울 수 있지만, 프로젝트가 커지고 복잡해질수록 다음과 같은 문제점이 발생할 수 있습니다.

- 코드 중복: 공통 모듈이 여러 저장소에 중복되어 관리되기 쉽습니다.
- 종속성 충돌: 서로 다른 저장소에서 동일한 라이브러리의 다른 버전을 사용할 경우 충돌이 발생할 수 있습니다.
- 일관성 부족: 코드 스타일과 규칙이 저장소마다 다를 수 있습니다.
- 복잡한 빌드 및 배포: 여러 저장소를 개별적으로 빌드하고 배포해야 하므로 관리가 복잡해집니다.

코드 중복의 경우, npm이나 github package로 공통 모듈을 배포하여 해결할 수 있지만,
이는 버전 관리와 배포 프로세스를 추가로 관리해야 한다는 단점이 있습니다.

또한, Polyrepo 방식의 프로젝트가 커질수록 monorepo로 전환하는 작업이 점점 더 어려워질 수 있습니다.
그래서 개인적으로 처음부터 monorepo 방식을 채택하는 것을 선호합니다.

## Monorepo로 구성하는 방법

Monorepo는 npm, yarn, pnpm같은 패키지 매니저의 워크스페이스 기능을 활용하여 구성할 수 있습니다.  
패키지 매니저는 각 프로젝트를 독립적인 패키지로 관리하고, 패키지 간의 연결을 쉽게 할 수 있도록 도와줍니다.

### 패키지 매니저가 제공하는 워크스페이스 기능

#### 워크스페이스란?

워크스페이스는 여러개의 package.json 파일을 가진 패키지를 하나의 저장소에서 관리할 수 있도록 해줍니다.  
워크스페이스를 사용하면, 모노레포 안의 패키지를 쉽게 연결할 수 있다는 점 입니다.

#### pnpm에서 워크스페이스 구성하기

직접 모노레포를 구성하면서 설명해보곘습니다.패키지 매니저는 pnpm을 기준으로 설명드리겠습니다.  
먼저, `pnpm-workspace.yaml` 파일을 생성하여 워크스페이스에 포함될 패키지를 정의합니다.

```yaml
packages:
  - 'apps/*'
  - 'packages/*'
```

- packages 필드는 워크스페이스에 포함될 패키지의 경로 패턴을 지정합니다.
- 보통 apps, packages라는 디렉토리를 만들어 각각 애플리케이션과 공통 모듈을 관리합니다.
  - apps 패키지에서는 실제로 배포되는 애플리케이션을 관리합니다.
  - packages 패키지에서는 여러 애플리케이션에서 공통으로 사용하는 모듈이나 라이브러리를 관리합니다.
- 반드시 apps와 packages 디렉토리를 사용할 필요는 없으며, 프로젝트 구조에 맞게 자유롭게 구성할 수 있습니다.

#### 패키지 간 의존성 연결하기 1: 패키지 설정하기

워크스페이스 내의 패키지들은 서로 의존성을 가질 수 있습니다.
예를 들어, `apps/blog` 패키지가 `packages/ui` 패키지를 의존한다고 가정해보겠습니다.
먼저, `packages/ui` 패키지의 `package.json` 파일을 다음과 같이 작성합니다.

```json
{
  "name": "@repo/ui", // 패키지 이름 설정
  "private": true, // 중요! 실수로 npm에 publish되지 않도록 막아주는 설정
  "version": "0.0.0",
  "type": "module",
  "main": "./src/entry.ts", // 패키지의 진입점 설정
  "types": "./src/entry.ts" // 타입 정의 파일 설정
  // ...
}
```

- name 필드는 패키지의 이름을 지정합니다. 워크스페이스 내에서 고유해야 합니다.
  - 패키지 이름에 @repo와 같은 스코프를 붙이는 것을 권장합니다.
  - 해당 패키지가 모노레포에서 사용하는 패키지임을 명시하려는 목적입니다.
- private 필드를 true로 설정하여 이 패키지가 npm에 게시되지 않도록 합니다

**중요: 해당 패키지에서 다른 패키지에 노출할 파일을 설정해야 합니다.**

- npm 패키지와 동일하게 설정하면 됩니다. 주로 main, types 필드를 사용하거나 exports를 설정합니다.
  - 해당 예제에서는 main 필드로 패키지의 진입점 파일을 지정했고, types 필드로 타입 정의 파일을 지정했습니다.
- 본 예제의 특이한 점으로는 패키지에서 ts파일을 그대로 노출한다는 점입니다.
  - 이는 ts파일을 컴파일하지 않고, 사용하는 쪽에서 컴파일하도록 하기 위함입니다.
  - 이렇게 하면 패키지를 따로따로 빌드할 필요가 없어서 편리합니다.
  - 만약, 사용하는 쪽에서 ts를 컴파일 하지 않거나 node_modules의 패키지에 대한 ts 컴파일이 잘 되지 않는다면, 패키지에서 js파일을 노출하도록 설정하면 됩니다.

#### 패키지 간 의존성 연결하기 2: 의존성 추가하기

이제 `apps/blog` 패키지에서 `@repo/ui` 패키지를 의존성으로 추가해보겠습니다.  
dependencies 또는 devDependencies에 다음과 같이 추가한 다음 `pnpm install` 명령어를 실행합니다.

```json
{
  "name": "blog",
  "version": "1.0.0",
  // ...
  "dependencies": {
    "@repo/ui": "workspace:*"
  }
}
```

- 워크스페이스 내의 패키지를 의존성으로 추가할 때는 버전 대신 `workspace:*`를 사용합니다.
- workspace를 붙이는 이유는 패키지 매니저가 해당 패키지를 워크스페이스 내에서 찾도록 하기 위함입니다. 이렇게 안하면 패키지 매니져는 npm registry에서 해당 패키지를 찾으려고 시도합니다.
- `*`는 모든 버전을 의미합니다. 특정 버전을 지정할 수도 있지만, 워크스페이스 내에서는 보통 `*`를 사용합니다.
- pnpm install 명령어를 실행하면, pnpm은 워크스페이스 내에서 `@repo/ui` 패키지를 찾아 `apps/blog` 패키지의 node_modules에 심볼릭 링크를 생성합니다.
- apps/blog 폴더의 node_modules를 확인해보면 @repo/ui 패키지가 심볼릭 링크로 연결된 것을 볼 수 있습니다.

![apps/blog폴더의 node_modules에 추가된 @repo/ui의 심볼릭 링크](/monorepo-node_modules.png)

- 이렇게 하면 `apps/blog` 패키지에서 `@repo/ui` 패키지를 마치 일반적인 npm 패키지처럼 사용할 수 있습니다.
