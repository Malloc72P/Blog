## Nextra API

포스트 목록 조회 기능 구현을 위해, 프로젝트의 모든 MDX 파일을 찾고, 이를 파싱하는 기능이 필요합니다.
그래야 빌드 시점에 포스트 목록 정보를 가져와서 랜딩페이지의 포스트 목록을 구현할 수 있습니다.
직접 FS 모듈을 사용해서 특정 경로 밑의 mdx파일을 읽고 파싱하여, 페이지 구조와 프론트매터 정보를 가져올 수 있지만, `Nextra`를 사용한다면 그럴 필요 없이, `getPageMap` API를 사용하면 됩니다.
`Nextra`는 인자로 넘긴 라우트 경로 밑의 페이지 정보를 반환하는 `getPageMap` 함수를 제공합니다.

```ts
import { getPageMap } from 'nextra/page-map';

const pageMap = await getPageMap('posts');
```

위의 예시코드에서 [`getPageMap`](https://nextra.site/api/getpagemap)은 posts 라우트 밑의 모든 페이지 정보를 담고 있는 객체를 반환합니다.  
리턴 타입은 `Promise<PageMapItem[]>`인데, PageMapItem은 폴더일 수 도 있고, MDX 파일일 수도 있으며, Meta 파일일 수 있습니다.  
이때 `PageMapItem` 타입은 아래와 같습니다.

```ts
type PageMapItem = Folder | MdxFile | MetaJsonFile;
```

공통점이 없는 세가지 타입으로 유니온 타입인 상태라, 객체가 폴더인지 MDX 파일인지 런타임에 구분해내기 까다롭습니다.  
물론 방법이 아예 없는건 아니지만, Nextra의 `normalizePages` API를 사용하면, Item 타입으로 정규화되어 코드가 간단해집니다.

```ts
type NormalizedResult = {
  activeType?: string;
  activeIndex: number;
  activeThemeContext: PageTheme;
  activeMetadata?: FrontMatter;
  activePath: Item[];
  directories: Item[];
  docsDirectories: DocsItem[];
  flatDocsDirectories: DocsItem[];
  topLevelNavbarItems: (PageItem | MenuItem)[];
};
```

`normalizePages`는 Nextra 테마를 위해 데이터를 가공하는 API 입니다.  
테마를 직접 만드는 경우에도 필요한 데이터는 크게 다르지 않고, 또 가공된 데이터에서 입맛에 맞게 추가 가공하는 것이 더 편하기 때문에,
`normalizePages`를 사용하는것이 좋다고 생각합니다. 다만, 이 부분은 `normalizePages`는 필수는 아니기 때문에, 상황에 맞는 것을 사용하면 됩니다.  
제 경우엔 PageMapItem 타입을 사용하는것이 너무 불편하여 `normalizePages를` 사용했습니다.

## 모든 포스트 목록을 조회하는 API 만들기

앞서 말한 `getPageMap과` `normalizePages를` 조합하여, 아래와 같이 모든 포스트 목록을 조회하는 코드를 작성했습니다.

```ts
const pageMap = await getPageMap(fullRoute);

const { directories } = normalizePages({
  list: pageMap,
  route: '/posts',
});

let posts = directories
  .reduce((acc, curr) => collectPost(acc, curr), [] as Item[])
  .flat()
  .filter((post) => post.frontMatter)
  .filter((post) => !post.frontMatter.isSeriesLanding);

function collectPost(posts: Item[], current: Item) {
  posts.push(current);

  if (current.children) {
    for (const child of current.children) {
      collectPost(posts, child);
    }
  }

  return posts;
}
```

`getPageMap`은 라우트 구조로 계층화된 객체를 반환하는데, 제 경우엔 1차원 배열로 평탄화된 데이터가 필요했습니다.  
그래서 다음과 같이 코드를 작성했습니다.

1. `normalizePages`로 정규화
2. collectPost 재귀함수로, 각각의 폴더에서 모든 포스트를 재귀적으로 수집
3. flat을 통해 2차원 배열을 1차원 배열로 평탄화
4. post가 아닌 경우는 제외하도록 필터링

여기서 `post.frontMatter`가 등장하는데, MDX 문서는 프론트매터를 통해 문서의 메타 정보를 표현할 수 있습니다.  
여기에 날짜 정보를 추가하여, 아래와 같이 정렬합니다.

```ts
posts.sort(sortPostByCreatedAt);
```

## 요약

글이 조금 길어졌지만, 요약하면 아래와 같습니다.

1. `getPageMap`으로 지정한 라우트 경로 밑의 모든 MDX 문서 정보를 담은 객체 생성.
2. `normalizePages`로 처리하기 쉽게 데이터 가공

`getPageMap`과 `normalizePages` API를 사용하면, 간단하게 MDX 문서를 조회하고, 그 안의 프론트매터 정보를 읽을 수 있어서 매우 편리했습니다.
만약 이걸 직접 구현했다면... 꽤 시간을 많이 잡아먹는 작업이 되었을 것 같습니다. FS 모듈로 특정 경로 밑의 모든 파일에 대한 계층 정보를 생성하고,
MDX 파일은 파싱해서 프론트 매터 정보를 생성해야 하니까요. 하지만 Nextra가 이걸 대신 해주니 정말 다행입니다.

다음은 블로그 구현에 대해 좀 더 자세하게 다루겠습니다. 읽어주셔서 감사합니다.

export const metadata = {
  title: '블로그 만들기 시리즈 Part 3: Nextra API로 시리즈와 태그 구현하기',
  series: 'blog-making-series',
  tags: ['NextJS', 'Nextra', 'getPageMap', 'normalizePages'],
  date: '2025-04-12 22:42',
};
